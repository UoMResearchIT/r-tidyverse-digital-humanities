---
title: Creating Publication-Quality Graphics
teaching: 60
exercises: 20
questions:
- "How can I create and save publication-quality graphics in R?"
objectives:
- "To be able to use ggplot2 to generate publication quality graphics."
- "To understand the basic grammar of graphics, including the aesthetics and geometry layers, adding statistics, transforming scales, and coloring or panelling by groups."
- "To understand how to save plots in a variety of formats"
- "To be able to find extensions for `ggplot2` to produce custom graphics"
keypoints:
- "Use `ggplot2` to create plots."
- "We can feed the output of a `dplyr` pipe into `ggplot2` to pre-process data"
- "Plots are built up using layers: aesthetics, geometry, statistics, scale transformation, and grouping."
source: Rmd
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("06-")
library(tidyverse)
# twitterData <- read_csv("data/twitterData.csv")
```

Plotting our data is one of the best ways to
quickly explore it and the various relationships
between variables.  For example in the last challenge of the previous episode we calculated the number of times each word was used on each day in January.  Until we plot the data it is very difficult to get a feel for what's happening.  Are some words becoming more prevalent? Is there a weekly cycle, with some words being more or less prevalent on certain days of the week?

There are three main plotting systems in R,
the [base plotting system][base], the [lattice][lattice]
package, and the [ggplot2][ggplot2] package.

[base]: http://www.statmethods.net/graphs/
[lattice]: http://www.statmethods.net/advgraphs/trellis.html
[ggplot2]: http://www.statmethods.net/advgraphs/ggplot2.html

Today we'll be learning about the ggplot2 package, which is part of the tidyverse.  It is the most effective for creating 
publication quality graphics. There are many extension packages for ggplot2, which make it easy to produce specialised types of
graph, such as survival plots, geographic maps and ROC curves.

ggplot2 is built on the grammar of graphics, the idea that any plot can be
expressed from the same set of components: a **data** set, a
**coordinate system**, and a set of **geoms**--the visual representation of data
points.    

The key to understanding ggplot2 is thinking about a figure in layers.
This idea may be familiar to you if you have used image editing programs like Photoshop, Illustrator, or
Inkscape.

Let's start off with an example, using our Twitter data.   The data-set we've been working with so far today is rather large.  Although `ggplot2` can plot large data-sets, it will be easier to explain what it's doing if we use a smaller data-set.  

The file `monthlyBae.csv` contains the number of times "bae" was used in each state in each month (in the `cases` column), and the proportion of the total tokens (words) used in each state in each month (in the `tokenProp` column).

Let's read the data in, using `read_csv()`:

```{r}
monthlyData <- read_csv("data/monthlyBae.csv")
```

The guessed column types look OK, so we'll use the `col_types` argument to specify them

```{r}
monthlyData <- read_csv("data/monthlyBae.csv",
                        col_types =
                          cols( word = col_character(),
                                monthyear = col_date(format = ""),
                                stateCode = col_character(),
                                Region = col_character(),
                                cases = col_integer(),
                                totalTokens = col_integer(),
                                tokenProp = col_double()
                          ))

monthlyData
```

All of the data for each month has been aggregated into a single row.  R doesn't have a data-type for dates that are just a month and a year, so I've arbitrarily used the first of the month as a "placeholder".

To illustrate ggplot, I'll generate an example graph.  Don't worry about what the code is doing at this stage; I'll pull the command apart after:

```{r}
  ggplot(monthlyData, aes(x = monthyear, y = cases)) +
  geom_point()
```


So the first thing we do is call the `ggplot` function. This function lets R
know that we're creating a new plot, and any of the arguments we give the
`ggplot` function are the *global* options for the plot: they apply to all
layers on the plot.

We've passed in two arguments to `ggplot`. First, we tell `ggplot` what data we
want to show on our figure, in this example the monthly Twitter data we just read in. For the second argument we passed in the `aes` function, which
tells `ggplot` how variables in the **data** map to *aesthetic* properties of
the figure (i.e. something we can see on the graph), in this case the **x** and **y** locations. Here we told `ggplot` we
want to plot the "date" column of the Twitter data on the x-axis, and
the "cases" column on the y-axis. 

By itself, the call to `ggplot` isn't enough to draw a figure:

```{r}
ggplot(monthlyData, aes(x = monthyear, y = cases)) 
```

We need to tell `ggplot` how we want to visually represent the data, which we
do by adding a new **geom** layer. In our example, we used `geom_point`, which
tells `ggplot` we want to visually represent the relationship between **x** and
**y** as a scatter-plot of points.  Each row in our tibble causes a single point to be drawn:

```{r lifeExp-vs-gdpPercap-scatter2}
ggplot(monthlyData, aes(x = monthyear, y = cases)) +
  geom_point()
```

## Combining `dplyr` and `ggplot2`

As `gplot2` is part of the tidyverse, we can use it with pipes.  As we will see later in the 
episode, this will be particularly useful if we need to modify the data before plotting it.

We can repeat the above plot, using a pipe, as follows:

```{r}
monthlyData %>%
  ggplot(aes(x = monthyear, y = cases)) +
  geom_point()
```
Note that the `ggplot2` commands are joined by the `+` symbol and not the `%>%` symbol.  It may help to remember that we **add** layers to our plot.

There are a couple of benefits to using pipes with ggplot.  The first is that RStudio can normally work out what variables are in the tibble you're piping to ggplot, and so the <kbd>Tab</kbd> completion will work.  We can also use a processing pipeline to pre-process our data.  For example, if
we only want to look at how the prevalence of "bae" varied in states in the western region, we could use

```{r}
monthlyData %>%
  filter(Region == "West") %>% 
  ggplot(aes(x = monthyear, y = cases)) +
  geom_point()
```

## Challenge 1

Plotting the number of times "bae" was used may not be the most sensible approach, as it does not take account of the difference in the amount of Twitter use in the different states.  `tokenProp` contains the proportion of all tokens (essentially words) used in each state that were "bae".  

Modify the graph so that it plots `tokenProp` instead of `cases` on the y axis.

The `aes()` function maps a visual property of the graph (for example what's on the y axis) to a variable in the data.  Another visual property of the graph we can change is the point colour.  Modify the aesthetic on your graph so that the colour (or color  - ggplot accepts either spelling) of the points depends on the region

## Solution to challenge 1

```{r ch1-sol}
monthlyData %>%
  ggplot(aes(x = monthyear, y = tokenProp)) +
  geom_point()
```

We can colour the points according to the region by adding `colour = Region` to the aesthetic:
```{r ch1-sol-b}
monthlyData %>%
  ggplot(aes(x = monthyear, y = tokenProp, colour = Region)) +
  geom_point()
```

{: .solution}
{: .challenge}

## Joining the dots

Plotting this data using points (with `geom_point()`) doesn't show the data to best effect.  It would be more useful if we could follow the prevalence of each state over time.  `geom_line()` lets us do this.  

Replacing `geom_point()` with `geom_line()` in the solution to the previous challenge gives: 

```{r}
monthlyData %>%
  ggplot(aes(x = monthyear, y = tokenProp, colour = Region)) +
  geom_line()
```

This probably isn't quite what you were expecting.   ggplot has drawn a single line for each region, rather than a single line for each country.    We need to tell ggplot that each state is a separate group.  The property of the graph is `group`. The data associated with each `stateCode` is in the same group (if we plotted a the data for a single state we would expect a single line).  We modify the aesthetic function to include this mapping: 


```{r}
monthlyData %>%
  ggplot(aes(x = monthyear, y = tokenProp,
             colour = Region, group = stateCode)) +
  geom_line()
```

We can see the aesthetics (x, y, group, etc.) that each `geom_` function uses by looking at its help page.  As with any R function, enter `?functonName()` or use the search tab in the lower right window in RStudio to bring up the help. 

RStudio also includes a really useful "cheatsheet" which summarises the most common ggplot functions and their aesthetics; this can be found in the help menu.


## Layers and aesthetics

We can include more than one layer in the graph by adding additional geoms.  For example, to plot points and lines:

```{r}
monthlyData %>%
  ggplot(aes(x = monthyear, y = tokenProp,
             colour = Region, group = stateCode)) +
  geom_line() +
  geom_point()
```
In the graph in challenge 2 the aesthetic we defined applies to all of the plot layers; both the points
and the lines are coloured according to their region.  In this section we'll explain how to modify the aesthetics of the graph so that they only apply to certain layers.

The most important thing to remember about aesthetics is that they map a variable in the data to a property of the graph.  In the example above we mapped `date` to the x axis, `tokenProp` to the y axis and Region to the colour property of the graph.  

The aesthetic defined in the `ggplot()` function can be thought of as the "master" aesthetic.  The mappings of graph-property to variable we define in it will apply to all of the geoms in the graph.  Both the points and lines are coloured according to region.  We can define aesthetics in a more granular way by applying them to a specific geom.  For example:

```{r}
monthlyData %>%
  ggplot(aes(x = monthyear, y = tokenProp,
             group = stateCode)) +
  geom_line(aes(colour = Region)) +
  geom_point()
```

Here I've moved the `colour` property from the master aesthetic to a new `aesthetic()` in `geom_line()`.   This overrides the master aesthetic's colour property (which is undefined, so no colour is used) on `geom_line()`.  `geom_point()` doesn't have its own aesthetic, so it uses the master aesthetic - so the points appear in a single colour.

What if we want to print our points in a colour other than the default black?  Aesthetics map
data to a property of the graph.  If we want to change the colour of all our points, we are not using 
the data to specify the colour, so we don't need to use an aesthetic mapping.  Instead we specify the colour directly in the geom:

```{r lifeExp-line-point4}
monthlyData %>%
  ggplot(aes(x = monthyear, y = tokenProp,
             group = stateCode)) +
  geom_line(aes(colour = Region)) +
  geom_point(colour = "red")
```

Each layer is drawn on top of the previous layer. In
this example, the points have been drawn *on top of* the lines. If we swap the order
of our `geom_line()` and `geom_point()`, the points appear **behind** the lines:

```{r}
monthlyData %>%
  ggplot(aes(x = monthyear, y = tokenProp,
             group = stateCode)) +
  geom_point(colour = "red") + 
  geom_line(aes(colour = Region)) 
```


> ## Tip: Transparency
>
> If you have a lot of data or many layers, it can be useful to make some (semi)-transparent.
> You can do this by setting the `alpha` property to a value between 0 (fully transparent), and 1 (fully opaque).
{: .callout}

## Multi-panel figures

There's still a lot going on in this graph.  It may clearer if we plotted a separate graph
for each region. We can split the plot into  multiple panels by adding a layer of **facet** panels: 

```{r}

monthlyData %>%
  ggplot(aes(x = monthyear, y = tokenProp,
             group = stateCode)) +
  geom_point() + 
  geom_line() +
  facet_wrap("Region")
```

We have removed
`colour=Region` from the aesthetic since colouring each line by region conveys no additional
information.  Note that the variable we are faceting by needs to be placed in quotes.

## More on faceting

It's also possible to facet by one or two variables on a grid, using the `facet_grid()` function.  For example,
if we had included all the words in our grouped data, we could produce a grid of graphs by word and region:

(I've included the option `scale = "free_y"` so that each row gets its own scale.  I've done this because the prevalence of each word varies)

```{r}
monthlyDataAll <- read_csv("data/monthlyAll.csv")

monthlyDataAll %>%
  ggplot(aes(x = monthyear, y = tokenProp,
             group = stateCode)) +
  geom_point() + 
  geom_line() +
  facet_grid(word ~ Region, scale = "free_y")

```


This uses R's formula notation to specify how we want to arrange to grid; see `?facet_grid` for more details.

{: .callout}

## Challenge 3

In this challenge you will look at how the total number of tokens (e.g. words) tweeted varies with time.

Try two different approaches to visualising this data:

* Plot all the data on a single graph, colouring each states's data by region
* Facet the data by region.

## Solution to challenge 3

* Plot all the data on a single graph, colouring each states's data by region

```{r}
monthlyData %>% 
  ggplot(aes(x = monthyear, y = totalTokens, colour = Region, group = stateCode)) +
  geom_line()
```

* Facet the data by region.

```{r}
monthlyData %>% 
  ggplot(aes(x = monthyear, y = totalTokens, group = stateCode)) +
  geom_line() +
  facet_wrap("Region")
```

The much greater volume of tokens coming from the southern and western states makes it difficult to see what's 
going on in the midwest and northeastern states (where the volume of tokens is much lower). One way of dealing with this is to allow each facet to have its own scale on the y axis.   This can be done by passing the `scales = "free_y"` option to `facet_wrap()`.  This can be useful in some circumstances.  It does, however, make
it very difficult to compare data in different continents, and is arguably misleading.

Another approach is to use a log scale on the y axis.  We'll cover this shortly.
{: .solution}
{: .challenge}


## Aside: Interactively exploring graphs

You might be wondering which states have the largest volume of tokens. Unfortunately 
isn't an easy way of doing this neatly in ggplot2.  One approach is to use `geom_text()` to label each data point with the state (this uses the `label` aesthetic to select which variable in the data to use as the label):
W
```{r}
monthlyData %>% 
  ggplot(aes(x = monthyear, y = totalTokens, group = stateCode, label = stateCode)) +
  geom_line() +
  geom_text() +
  facet_wrap("Region")
```

The output from this clearly isn't suitable for publication, but it may be sufficient if you just need to produce something for your own use.

The labels for each data point overlap each other, and are plotted for each data point.  You can deal with the latter issue by creating a new variable which only contains the label for one point per group (i.e per country), and for the groups you wish to label.  You can do this using `mutate` and `ifelse` as described at the end of the previous episode.

It's also possible to make a graph with "tooltips", so that the country pops up when you hover the mouse over a line.  `ggplot2` can't do this automatically, but an extension package [ggiraph`](https://davidgohel.github.io/ggiraph/index.html) provides this functionality.  The package's documentation has full examples.  

{: .callout}

## Pre processing data

When we want to start sub-setting and mutating the data before plotting, the usefulness of
"piped" data-analysis becomes apparent; we can perform our data transformations and then
send the result to `ggplot2` without making an intermediate data set.

For example, if we wanted to produce a version of the graph in challenge 3, but only for countries in the Americas, we could use:


```{r}

gapminder %>% 
  filter(continent == "Americas") %>% 
  ggplot(aes(x = year, y = gdpPercap, group = country)) +
  geom_line() +
  facet_wrap("continent")
```


## Challenge 4

Rather than plotting the life expectancy of each country over time, make a plot showing the average life expectancy in each continent over time.   

Hint - Challenge 3 of the [previous episode](../04-dplyr) may be useful.  This can then be piped into a ggplot command.

## Solution to challenge 4

```{r}
gapminder %>% 
  group_by(continent, year) %>% 
  summarise(mean_lifeExp = mean(lifeExp)) %>% 
  ggplot(aes(x = year, y=mean_lifeExp, colour = continent)) +
  geom_line()
```

{: .solution}
{: .challenge}



## Transformations 

Ggplot also makes it easy to transform axes, to better show our data.  To
demonstrate we'll go back to our first example:

```{r lifeExp-vs-gdpPercap-scatter3, message=FALSE}
gapminder %>% ggplot(aes(x = gdpPercap, y = lifeExp)) +
  geom_point()
```

Currently it's hard to see the relationship between the points due to some strong
outliers in GDP per capita. We can change the scale of units on the x axis using
the *scale* functions. These control the mapping between the data values and
visual values of an aesthetic. We also modify the transparency of the
points, using the *alpha* function, which is especially helpful when you have
a large amount of data which is very clustered.

```{r axis-scale}
gapminder %>% ggplot(aes(x = gdpPercap, y = lifeExp)) +
  geom_point(alpha = 0.5) + scale_x_log10()
```

The `scale_x_log10` function applied a transformation to the values of the gdpPercap
column before rendering them on the plot, so that each multiple of 10 now only
corresponds to an increase in 1 on the transformed scale, e.g. a GDP per capita
of 1,000 is now 3 on the x axis, a value of 10,000 corresponds to 4 on the x-
axis and so on. This makes it easier to visualize the spread of data on the
x-axis.  If we want plot the y-axis on a log scale we can use the `scale_y_log10` function.

## Challenge 5 

Modify the faceted plot you produced in challenge 3 to show GDP per capita on a log scale.

## Solution to challenge 5

We can add the `scale_y_log10()` to our plotting command:

```{r}
gapminder %>% 
  ggplot(aes(x = year, y = gdpPercap, group = country)) +
  geom_line() +
  facet_wrap("continent") + 
  scale_y_log10()
```

Although this makes it easier to visualise all of the data on a single plot, it makes the inequality in GDP per capita
between the difference continents much less obvious.  

If we plot the data with a linear scale the inequality is more obvious, but this masks the individual trajectories of
many countries' GDPs . Decisions about how best to plot data are beyond the scope of this course.  Research IT offers a course, [Introduction to data visualisation and analysis](https://app.manchester.ac.uk/rintrovis), which covers this topic in much more detail.

{: .solution}
{: .challenge}

## Plotting 1D data

In the examples so far we've plotted one variable against another.  Often we wish to plot single variable. We can
plot counts using `geom_bar()`.  For example, to plot the number of counties in the gapminder data that are in each
continent we can use:

```{r}
gapminder %>% filter(year == 2007) %>%
  ggplot(aes(x=continent)) + 
  geom_bar()
```

We filter to a single year of data to avoid multiple counting

We often wish to explore the distribution of a continuous variable.  We can do this using a histogram (`geom_histogram()`), 
or a density plot (`geom_density()`)

For example, to produce a histogram of GDPs per capita for countries in Europe in 2007:

```{r}
gapminder %>% filter(year == 2007, continent == "Europe") %>% 
  ggplot(aes(x=gdpPercap)) + geom_histogram(bins = 10)
```

We can specify the number of bins (`bins = `), or the width of a bin (`binwidth = `).

We can plot a density plot using `geom_density()`.  This is a smoothed version of a histogram.

```{r}
gapminder %>% 
  filter(year == 2007, continent == "Europe") %>% 
  ggplot(aes(x = gdpPercap)) + 
  geom_density() 
```

By default the density estimate is drawn in outline (i.e. it isn't filled in).  We can use the `fill` attribute to fill it in; this can be
passed in the aesthetic (e.g. `aes(x = gdpPercap, fill = ...))`) to fill according to the data, or directly to `geom_density()`. The `colour` attribute controls the _outline_ of the shape.  For example:


```{r}
gapminder %>% 
  filter(year == 2007, continent == "Europe") %>% 
  ggplot(aes(x = gdpPercap)) + 
  geom_density(fill = "red", colour="blue") 
```

> ## Challenge 6
> 
> In this challenge, we'll extend the plot above to compare the distributions of GDP per capita in Europe and Africa over time.
> As the challenge is quite long, it's broken down into sections.  Please try each section
> before looking at the answer.
>
> a.  We'll start off by plotting the data for a single year, before extending the plot for multiple years.  Using the code above as a starting point, write some code to return a tibble containing the data for Europe and Africa in 2007.  Hint: the `%in%` operator may be useful.
>
> > ## Solution a
> > 
> > ```{r}
> > gapminder %>% 
> >   filter(year == 2007) %>% 
> >   filter(continent %in% c("Europe", "Africa"))
> > ```
> > This returns a tibble, which we can then pipe into ggplot.
> {: .solution}
> 
> b. Pipe the results of part a into ggplot, to make a density plot of GDP per capita, setting the fill colour by continent (e.g. each continent has its own density estimate)
> 
> > ## Solution b
> > 
> > ```{r}
> > 
> > gapminder %>% 
> >   filter(year == 2007) %>% 
> >   filter(continent %in% c("Europe", "Africa")) %>% 
> >   ggplot(aes(x = gdpPercap, fill = continent)) +
> >   geom_density()
> > ```
> >
> {: .solution}
>
> c. This looks OK, but the continent's density estimates overlay each other.  Use the `alpha =` option to make each density estimate
> semi transparent
>
> > ## Solution c
> >
> > ```{r}
> > gapminder %>% 
> >   filter(year == 2007) %>% 
> >   filter(continent %in% c("Europe", "Africa")) %>% 
> >   ggplot(aes(x = gdpPercap, fill = continent)) +
> >   geom_density(alpha = 0.5) 
> > ```
> > 
> {: .solution}
> 
> d.  Let's take a look at how the relative GDPs per capita have changed over time.  We can use `facet_wrap()` to do  this.  
> Modify your code to produce a separate graph for each year
>
>
> > ## Solution d
> >
> > ```{r}
> > gapminder %>% 
> >   filter(continent %in% c("Europe", "Africa")) %>% 
> >   ggplot(aes(x = gdpPercap, fill = continent)) +
> >   geom_density(alpha = 0.5) +
> >   facet_wrap("year")
> > ```
> > Note that you need to remove the `filter(year == 2007)` line from the code.
> >
> {: .solution}
{: .challenge}
  

## Modifying text

To clean this figure up for a publication we need to change some of the text
elements.  For example the axis labels should be "human readable" rather than 
the variable name from the data-set.  We may also wish to change the text size, etc.

We can do this by adding a couple of different layers. The **theme** layer
controls the axis text, and overall text size. Labels for the axes, plot 
title and any legend can be set using the `labs` function. Legend titles
are set using the same names we used in the `aes` specification; since we used the `fill` property to 
colour by continent we use `fill = "Continent` in the `labs()` function.  

```{r theme}
gapminder %>% 
  filter(continent %in% c("Europe", "Africa")) %>% 
  ggplot(aes(x = gdpPercap, fill = continent)) +
  geom_density(alpha = 0.5) +
  facet_wrap("year") + 
  labs(
    x = "GDP per capita", # x axis title
    y = "Density",   # y axis title
    title = "Figure 1",      # main title of figure
    fill = "Continent"      # title of legend
  ) 
```

RStudio provides a really useful [cheat sheet][cheat] of the different layers available, and more
extensive documentation is available on the [ggplot2 website][ggplot-doc].

[cheat]: http://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf
[ggplot-doc]: http://docs.ggplot2.org/current/

## Saving plots

Having produced a plot, we can save it, or copy it to the clipboard using the "Export" command at the top of RStudio's plot window.

It's a better idea to save your plots as part of your scripts; this way if you modify your analysis code, you _know_ the plot will reflect the results of the code.  If you manually save the plot, you have to remember to do this after changing the script.  

We can save the most recently produced ggplot using the `ggsave()` function:

```{r, eval = FALSE}
ggsave("plots/myplot.png")
# Can also set the size of plot
ggsave("plots/myplot.pdf", width = 20, height = 20, units = "cm")

```

The help for the `ggsave()` function lists the image formats that are available, as well as the options for setting the resolution and size of the saved image.

## ggplot themes and extensions

ggplot is very flexible, and its capabilities can be extended.  

The _theme_ of a plot affects the background, axes etc.  The [ggplot2 themes package](https://cran.r-project.org/web/packages/ggthemes/) contains many useful (and not so useful) themes we can apply to our data.  The [cowplot package](https://cran.r-project.org/web/packages/cowplot/index.html) makes it easy to plot sub-plots, and to overlay plots within plots.  

The [ggplot2 exensions](http://www.ggplot2-exts.org/) pages lists R packages that can extend its capabilities. If you have a specialised plotting need (for example plotting ROC curves, survival data, or time series) there are packages that will allow you to make these plots with minimal effort. [The top 50 ggplot2 visualisations page](http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html) provides examples (with full code) of almost any type of graph you might want to make. 

As an example of how easy it can be to extend ggplot, we will use the `ggridges` plot to produce a stacked density plot, to better visualise the previous figure:

```{r, echo=FALSE, message=FALSE, warning=FALSE}
if (!require("ggridges", quietly = TRUE)) {
  install.packages("ggridges")
  library("ggridges")
}
```

```{r, ridgesplot}
library(ggridges)
gapminder %>% 
  filter(continent %in% c("Europe", "Africa")) %>% 
  ggplot(aes(x = gdpPercap, y = factor(year), fill = continent)) +
  geom_density_ridges(alpha = 0.5) 
```

[Data Visualization - A practical Introduction](http://socviz.co/) is an online book which covers good practice in data visualisation, using R and ggplot2 to illustrate this.


